/*
 * DataForSEO API documentation
 * DataForSEO API is the starting point on your journey towards building powerful SEO software. With DataForSEO you can get all the data you need to build an efficient application while also saving your time and budget. DataForSEO API is using the REST technology for interchanging data between your application and our service. The data exchange is made through the widely used HTTP protocol, which allows applying our API to almost all programming languages.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.github.dataforseo.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import io.github.dataforseo.client.JSON;

/**
 * BaseOnPageLinkItemInfo
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-11-28T21:14:57.172884200+02:00[Europe/Helsinki]", comments = "Generator version: 7.8.0")
public class BaseOnPageLinkItemInfo {
  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  protected String type;

  public static final String SERIALIZED_NAME_DOMAIN_FROM = "domain_from";
  @SerializedName(SERIALIZED_NAME_DOMAIN_FROM)
  private String domainFrom;

  public static final String SERIALIZED_NAME_DOMAIN_TO = "domain_to";
  @SerializedName(SERIALIZED_NAME_DOMAIN_TO)
  private String domainTo;

  public static final String SERIALIZED_NAME_PAGE_FROM = "page_from";
  @SerializedName(SERIALIZED_NAME_PAGE_FROM)
  private String pageFrom;

  public static final String SERIALIZED_NAME_PAGE_TO = "page_to";
  @SerializedName(SERIALIZED_NAME_PAGE_TO)
  private String pageTo;

  public static final String SERIALIZED_NAME_LINK_FROM = "link_from";
  @SerializedName(SERIALIZED_NAME_LINK_FROM)
  private String linkFrom;

  public static final String SERIALIZED_NAME_LINK_TO = "link_to";
  @SerializedName(SERIALIZED_NAME_LINK_TO)
  private String linkTo;

  public static final String SERIALIZED_NAME_DOFOLLOW = "dofollow";
  @SerializedName(SERIALIZED_NAME_DOFOLLOW)
  private Boolean dofollow;

  public static final String SERIALIZED_NAME_PAGE_FROM_SCHEME = "page_from_scheme";
  @SerializedName(SERIALIZED_NAME_PAGE_FROM_SCHEME)
  private String pageFromScheme;

  public static final String SERIALIZED_NAME_PAGE_TO_SCHEME = "page_to_scheme";
  @SerializedName(SERIALIZED_NAME_PAGE_TO_SCHEME)
  private String pageToScheme;

  public static final String SERIALIZED_NAME_DIRECTION = "direction";
  @SerializedName(SERIALIZED_NAME_DIRECTION)
  private String direction;

  public static final String SERIALIZED_NAME_IS_BROKEN = "is_broken";
  @SerializedName(SERIALIZED_NAME_IS_BROKEN)
  private Boolean isBroken;

  public static final String SERIALIZED_NAME_IS_LINK_RELATION_CONFLICT = "is_link_relation_conflict";
  @SerializedName(SERIALIZED_NAME_IS_LINK_RELATION_CONFLICT)
  private Boolean isLinkRelationConflict;

  public BaseOnPageLinkItemInfo() {
    this.type = this.getClass().getSimpleName();
  }

  public BaseOnPageLinkItemInfo type(String type) {
    this.type = type;
    return this;
  }

  /**
   * type of element
   * @return type
   */
  @javax.annotation.Nullable
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }


  public BaseOnPageLinkItemInfo domainFrom(String domainFrom) {
    this.domainFrom = domainFrom;
    return this;
  }

  /**
   * referring domain the link was found on this domain
   * @return domainFrom
   */
  @javax.annotation.Nullable
  public String getDomainFrom() {
    return domainFrom;
  }

  public void setDomainFrom(String domainFrom) {
    this.domainFrom = domainFrom;
  }


  public BaseOnPageLinkItemInfo domainTo(String domainTo) {
    this.domainTo = domainTo;
    return this;
  }

  /**
   * referenced domain the link is pointing to this domain
   * @return domainTo
   */
  @javax.annotation.Nullable
  public String getDomainTo() {
    return domainTo;
  }

  public void setDomainTo(String domainTo) {
    this.domainTo = domainTo;
  }


  public BaseOnPageLinkItemInfo pageFrom(String pageFrom) {
    this.pageFrom = pageFrom;
    return this;
  }

  /**
   * referring page relative URL of the page on which the link was found
   * @return pageFrom
   */
  @javax.annotation.Nullable
  public String getPageFrom() {
    return pageFrom;
  }

  public void setPageFrom(String pageFrom) {
    this.pageFrom = pageFrom;
  }


  public BaseOnPageLinkItemInfo pageTo(String pageTo) {
    this.pageTo = pageTo;
    return this;
  }

  /**
   * referenced page relative URL of the page to which the link is pointing
   * @return pageTo
   */
  @javax.annotation.Nullable
  public String getPageTo() {
    return pageTo;
  }

  public void setPageTo(String pageTo) {
    this.pageTo = pageTo;
  }


  public BaseOnPageLinkItemInfo linkFrom(String linkFrom) {
    this.linkFrom = linkFrom;
    return this;
  }

  /**
   * referring page absolute URL of the page on which the link was found
   * @return linkFrom
   */
  @javax.annotation.Nullable
  public String getLinkFrom() {
    return linkFrom;
  }

  public void setLinkFrom(String linkFrom) {
    this.linkFrom = linkFrom;
  }


  public BaseOnPageLinkItemInfo linkTo(String linkTo) {
    this.linkTo = linkTo;
    return this;
  }

  /**
   * referenced page absolute URL of the page to which the link is pointing
   * @return linkTo
   */
  @javax.annotation.Nullable
  public String getLinkTo() {
    return linkTo;
  }

  public void setLinkTo(String linkTo) {
    this.linkTo = linkTo;
  }


  public BaseOnPageLinkItemInfo dofollow(Boolean dofollow) {
    this.dofollow = dofollow;
    return this;
  }

  /**
   * indicates whether the link is dofollow if the value is true, the link doesnâ€™t have a rel&#x3D;\&quot;nofollow\&quot; attribute
   * @return dofollow
   */
  @javax.annotation.Nullable
  public Boolean getDofollow() {
    return dofollow;
  }

  public void setDofollow(Boolean dofollow) {
    this.dofollow = dofollow;
  }


  public BaseOnPageLinkItemInfo pageFromScheme(String pageFromScheme) {
    this.pageFromScheme = pageFromScheme;
    return this;
  }

  /**
   * url scheme of the referring page
   * @return pageFromScheme
   */
  @javax.annotation.Nullable
  public String getPageFromScheme() {
    return pageFromScheme;
  }

  public void setPageFromScheme(String pageFromScheme) {
    this.pageFromScheme = pageFromScheme;
  }


  public BaseOnPageLinkItemInfo pageToScheme(String pageToScheme) {
    this.pageToScheme = pageToScheme;
    return this;
  }

  /**
   * url scheme of the referenced page
   * @return pageToScheme
   */
  @javax.annotation.Nullable
  public String getPageToScheme() {
    return pageToScheme;
  }

  public void setPageToScheme(String pageToScheme) {
    this.pageToScheme = pageToScheme;
  }


  public BaseOnPageLinkItemInfo direction(String direction) {
    this.direction = direction;
    return this;
  }

  /**
   * direction of the link possible values: internal, external
   * @return direction
   */
  @javax.annotation.Nullable
  public String getDirection() {
    return direction;
  }

  public void setDirection(String direction) {
    this.direction = direction;
  }


  public BaseOnPageLinkItemInfo isBroken(Boolean isBroken) {
    this.isBroken = isBroken;
    return this;
  }

  /**
   * link is broken indicates whether a link is directing to a broken page or resource
   * @return isBroken
   */
  @javax.annotation.Nullable
  public Boolean getIsBroken() {
    return isBroken;
  }

  public void setIsBroken(Boolean isBroken) {
    this.isBroken = isBroken;
  }


  public BaseOnPageLinkItemInfo isLinkRelationConflict(Boolean isLinkRelationConflict) {
    this.isLinkRelationConflict = isLinkRelationConflict;
    return this;
  }

  /**
   * indicates that the link may have a conflict with another link if true, at least one link pointing to link_to has a rel&#x3D;\&quot;nofollow\&quot; attribute and at least one is dofollow
   * @return isLinkRelationConflict
   */
  @javax.annotation.Nullable
  public Boolean getIsLinkRelationConflict() {
    return isLinkRelationConflict;
  }

  public void setIsLinkRelationConflict(Boolean isLinkRelationConflict) {
    this.isLinkRelationConflict = isLinkRelationConflict;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BaseOnPageLinkItemInfo baseOnPageLinkItemInfo = (BaseOnPageLinkItemInfo) o;
    return Objects.equals(this.type, baseOnPageLinkItemInfo.type) &&
        Objects.equals(this.domainFrom, baseOnPageLinkItemInfo.domainFrom) &&
        Objects.equals(this.domainTo, baseOnPageLinkItemInfo.domainTo) &&
        Objects.equals(this.pageFrom, baseOnPageLinkItemInfo.pageFrom) &&
        Objects.equals(this.pageTo, baseOnPageLinkItemInfo.pageTo) &&
        Objects.equals(this.linkFrom, baseOnPageLinkItemInfo.linkFrom) &&
        Objects.equals(this.linkTo, baseOnPageLinkItemInfo.linkTo) &&
        Objects.equals(this.dofollow, baseOnPageLinkItemInfo.dofollow) &&
        Objects.equals(this.pageFromScheme, baseOnPageLinkItemInfo.pageFromScheme) &&
        Objects.equals(this.pageToScheme, baseOnPageLinkItemInfo.pageToScheme) &&
        Objects.equals(this.direction, baseOnPageLinkItemInfo.direction) &&
        Objects.equals(this.isBroken, baseOnPageLinkItemInfo.isBroken) &&
        Objects.equals(this.isLinkRelationConflict, baseOnPageLinkItemInfo.isLinkRelationConflict);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(type, domainFrom, domainTo, pageFrom, pageTo, linkFrom, linkTo, dofollow, pageFromScheme, pageToScheme, direction, isBroken, isLinkRelationConflict);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BaseOnPageLinkItemInfo {\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    domainFrom: ").append(toIndentedString(domainFrom)).append("\n");
    sb.append("    domainTo: ").append(toIndentedString(domainTo)).append("\n");
    sb.append("    pageFrom: ").append(toIndentedString(pageFrom)).append("\n");
    sb.append("    pageTo: ").append(toIndentedString(pageTo)).append("\n");
    sb.append("    linkFrom: ").append(toIndentedString(linkFrom)).append("\n");
    sb.append("    linkTo: ").append(toIndentedString(linkTo)).append("\n");
    sb.append("    dofollow: ").append(toIndentedString(dofollow)).append("\n");
    sb.append("    pageFromScheme: ").append(toIndentedString(pageFromScheme)).append("\n");
    sb.append("    pageToScheme: ").append(toIndentedString(pageToScheme)).append("\n");
    sb.append("    direction: ").append(toIndentedString(direction)).append("\n");
    sb.append("    isBroken: ").append(toIndentedString(isBroken)).append("\n");
    sb.append("    isLinkRelationConflict: ").append(toIndentedString(isLinkRelationConflict)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("type");
    openapiFields.add("domain_from");
    openapiFields.add("domain_to");
    openapiFields.add("page_from");
    openapiFields.add("page_to");
    openapiFields.add("link_from");
    openapiFields.add("link_to");
    openapiFields.add("dofollow");
    openapiFields.add("page_from_scheme");
    openapiFields.add("page_to_scheme");
    openapiFields.add("direction");
    openapiFields.add("is_broken");
    openapiFields.add("is_link_relation_conflict");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to BaseOnPageLinkItemInfo
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!BaseOnPageLinkItemInfo.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in BaseOnPageLinkItemInfo is not found in the empty JSON string", BaseOnPageLinkItemInfo.openapiRequiredFields.toString()));
        }
      }

      String discriminatorValue = jsonElement.getAsJsonObject().get("type").getAsString();
      switch (discriminatorValue) {
        case "alternate":
          AlternateLinkElementItem.validateJsonElement(jsonElement);
          break;
        case "anchor":
          AnchorLinkElementItem.validateJsonElement(jsonElement);
          break;
        case "image":
          ImageLinkElementItem.validateJsonElement(jsonElement);
          break;
        case "redirect":
          RedirectLinkElementItem.validateJsonElement(jsonElement);
          break;
        default:
          throw new IllegalArgumentException(String.format("The value of the `type` field `%s` does not match any key defined in the discriminator's mapping.", discriminatorValue));
      }
  }


  /**
   * Create an instance of BaseOnPageLinkItemInfo given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of BaseOnPageLinkItemInfo
   * @throws IOException if the JSON string is invalid with respect to BaseOnPageLinkItemInfo
   */
  public static BaseOnPageLinkItemInfo fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, BaseOnPageLinkItemInfo.class);
  }

  /**
   * Convert an instance of BaseOnPageLinkItemInfo to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

