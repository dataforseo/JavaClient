/*
 * DataForSEO API documentation
 * DataForSEO API is the starting point on your journey towards building powerful SEO software. With DataForSEO you can get all the data you need to build an efficient application while also saving your time and budget. DataForSEO API is using the REST technology for interchanging data between your application and our service. The data exchange is made through the widely used HTTP protocol, which allows applying our API to almost all programming languages.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.dataforseo.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.dataforseo.client.model.BaseSerpElementItem;
import org.dataforseo.client.model.StreamingQualityElement;
import org.dataforseo.client.model.Subtitles;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.dataforseo.client.JSON;

/**
 * YoutubeVideoInfoSerpElementItem
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-06-02T20:51:42.343286900+03:00[Europe/Kiev]")
public class YoutubeVideoInfoSerpElementItem extends BaseSerpElementItem {
  public static final String SERIALIZED_NAME_RANK_GROUP = "rank_group";
  @SerializedName(SERIALIZED_NAME_RANK_GROUP)
  private Integer rankGroup;

  public static final String SERIALIZED_NAME_RANK_ABSOLUTE = "rank_absolute";
  @SerializedName(SERIALIZED_NAME_RANK_ABSOLUTE)
  private Integer rankAbsolute;

  public static final String SERIALIZED_NAME_VIDEO_ID = "video_id";
  @SerializedName(SERIALIZED_NAME_VIDEO_ID)
  private String videoId;

  public static final String SERIALIZED_NAME_TITLE = "title";
  @SerializedName(SERIALIZED_NAME_TITLE)
  private String title;

  public static final String SERIALIZED_NAME_URL = "url";
  @SerializedName(SERIALIZED_NAME_URL)
  private String url;

  public static final String SERIALIZED_NAME_THUMBNAIL_URL = "thumbnail_url";
  @SerializedName(SERIALIZED_NAME_THUMBNAIL_URL)
  private String thumbnailUrl;

  public static final String SERIALIZED_NAME_CHANNEL_ID = "channel_id";
  @SerializedName(SERIALIZED_NAME_CHANNEL_ID)
  private String channelId;

  public static final String SERIALIZED_NAME_CHANNEL_NAME = "channel_name";
  @SerializedName(SERIALIZED_NAME_CHANNEL_NAME)
  private String channelName;

  public static final String SERIALIZED_NAME_CHANNEL_URL = "channel_url";
  @SerializedName(SERIALIZED_NAME_CHANNEL_URL)
  private String channelUrl;

  public static final String SERIALIZED_NAME_CHANNEL_LOGO = "channel_logo";
  @SerializedName(SERIALIZED_NAME_CHANNEL_LOGO)
  private String channelLogo;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_VIEWS_COUNT = "views_count";
  @SerializedName(SERIALIZED_NAME_VIEWS_COUNT)
  private Long viewsCount;

  public static final String SERIALIZED_NAME_LIKES_COUNT = "likes_count";
  @SerializedName(SERIALIZED_NAME_LIKES_COUNT)
  private Long likesCount;

  public static final String SERIALIZED_NAME_COMMENTS_COUNT = "comments_count";
  @SerializedName(SERIALIZED_NAME_COMMENTS_COUNT)
  private Long commentsCount;

  public static final String SERIALIZED_NAME_PUBLICATION_DATE = "publication_date";
  @SerializedName(SERIALIZED_NAME_PUBLICATION_DATE)
  private String publicationDate;

  public static final String SERIALIZED_NAME_TIMESTAMP = "timestamp";
  @SerializedName(SERIALIZED_NAME_TIMESTAMP)
  private String timestamp;

  public static final String SERIALIZED_NAME_KEYWORDS = "keywords";
  @SerializedName(SERIALIZED_NAME_KEYWORDS)
  private List<String> keywords;

  public static final String SERIALIZED_NAME_CATEGORY = "category";
  @SerializedName(SERIALIZED_NAME_CATEGORY)
  private String category;

  public static final String SERIALIZED_NAME_IS_LIVE = "is_live";
  @SerializedName(SERIALIZED_NAME_IS_LIVE)
  private Boolean isLive;

  public static final String SERIALIZED_NAME_DURATION_TIME = "duration_time";
  @SerializedName(SERIALIZED_NAME_DURATION_TIME)
  private String durationTime;

  public static final String SERIALIZED_NAME_DURATION_TIME_SECONDS = "duration_time_seconds";
  @SerializedName(SERIALIZED_NAME_DURATION_TIME_SECONDS)
  private Integer durationTimeSeconds;

  public static final String SERIALIZED_NAME_SUBTITLES = "subtitles";
  @SerializedName(SERIALIZED_NAME_SUBTITLES)
  private List<Subtitles> subtitles;

  public static final String SERIALIZED_NAME_STREAMING_QUALITY = "streaming_quality";
  @SerializedName(SERIALIZED_NAME_STREAMING_QUALITY)
  private List<StreamingQualityElement> streamingQuality;

  public YoutubeVideoInfoSerpElementItem() {
    this.type = this.getClass().getSimpleName();
  }

  public YoutubeVideoInfoSerpElementItem rankGroup(Integer rankGroup) {
    this.rankGroup = rankGroup;
    return this;
  }

   /**
   * group rank in SERP position within a group of elements with identical type values positions of elements with different type values are omitted from rank_group
   * @return rankGroup
  **/
  @javax.annotation.Nullable
  public Integer getRankGroup() {
    return rankGroup;
  }

  public void setRankGroup(Integer rankGroup) {
    this.rankGroup = rankGroup;
  }


  public YoutubeVideoInfoSerpElementItem rankAbsolute(Integer rankAbsolute) {
    this.rankAbsolute = rankAbsolute;
    return this;
  }

   /**
   * absolute rank in SERP for the target domain absolute position among all the elements in SERP
   * @return rankAbsolute
  **/
  @javax.annotation.Nullable
  public Integer getRankAbsolute() {
    return rankAbsolute;
  }

  public void setRankAbsolute(Integer rankAbsolute) {
    this.rankAbsolute = rankAbsolute;
  }


  public YoutubeVideoInfoSerpElementItem videoId(String videoId) {
    this.videoId = videoId;
    return this;
  }

   /**
   * ID of the video received in a POST array
   * @return videoId
  **/
  @javax.annotation.Nullable
  public String getVideoId() {
    return videoId;
  }

  public void setVideoId(String videoId) {
    this.videoId = videoId;
  }


  public YoutubeVideoInfoSerpElementItem title(String title) {
    this.title = title;
    return this;
  }

   /**
   * title of the video
   * @return title
  **/
  @javax.annotation.Nullable
  public String getTitle() {
    return title;
  }

  public void setTitle(String title) {
    this.title = title;
  }


  public YoutubeVideoInfoSerpElementItem url(String url) {
    this.url = url;
    return this;
  }

   /**
   * URL of the video
   * @return url
  **/
  @javax.annotation.Nullable
  public String getUrl() {
    return url;
  }

  public void setUrl(String url) {
    this.url = url;
  }


  public YoutubeVideoInfoSerpElementItem thumbnailUrl(String thumbnailUrl) {
    this.thumbnailUrl = thumbnailUrl;
    return this;
  }

   /**
   * the URL of the page where the thumbnail is hosted
   * @return thumbnailUrl
  **/
  @javax.annotation.Nullable
  public String getThumbnailUrl() {
    return thumbnailUrl;
  }

  public void setThumbnailUrl(String thumbnailUrl) {
    this.thumbnailUrl = thumbnailUrl;
  }


  public YoutubeVideoInfoSerpElementItem channelId(String channelId) {
    this.channelId = channelId;
    return this;
  }

   /**
   * the ID of the channel where the video is published
   * @return channelId
  **/
  @javax.annotation.Nullable
  public String getChannelId() {
    return channelId;
  }

  public void setChannelId(String channelId) {
    this.channelId = channelId;
  }


  public YoutubeVideoInfoSerpElementItem channelName(String channelName) {
    this.channelName = channelName;
    return this;
  }

   /**
   * the name of the channel where the video is published
   * @return channelName
  **/
  @javax.annotation.Nullable
  public String getChannelName() {
    return channelName;
  }

  public void setChannelName(String channelName) {
    this.channelName = channelName;
  }


  public YoutubeVideoInfoSerpElementItem channelUrl(String channelUrl) {
    this.channelUrl = channelUrl;
    return this;
  }

   /**
   * the URL of the channel where the video is published
   * @return channelUrl
  **/
  @javax.annotation.Nullable
  public String getChannelUrl() {
    return channelUrl;
  }

  public void setChannelUrl(String channelUrl) {
    this.channelUrl = channelUrl;
  }


  public YoutubeVideoInfoSerpElementItem channelLogo(String channelLogo) {
    this.channelLogo = channelLogo;
    return this;
  }

   /**
   * the URL of the page where the logo image of the channel is hosted
   * @return channelLogo
  **/
  @javax.annotation.Nullable
  public String getChannelLogo() {
    return channelLogo;
  }

  public void setChannelLogo(String channelLogo) {
    this.channelLogo = channelLogo;
  }


  public YoutubeVideoInfoSerpElementItem description(String description) {
    this.description = description;
    return this;
  }

   /**
   * description of the video
   * @return description
  **/
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public YoutubeVideoInfoSerpElementItem viewsCount(Long viewsCount) {
    this.viewsCount = viewsCount;
    return this;
  }

   /**
   * number of views of the video
   * @return viewsCount
  **/
  @javax.annotation.Nullable
  public Long getViewsCount() {
    return viewsCount;
  }

  public void setViewsCount(Long viewsCount) {
    this.viewsCount = viewsCount;
  }


  public YoutubeVideoInfoSerpElementItem likesCount(Long likesCount) {
    this.likesCount = likesCount;
    return this;
  }

   /**
   * number of likes on the video
   * @return likesCount
  **/
  @javax.annotation.Nullable
  public Long getLikesCount() {
    return likesCount;
  }

  public void setLikesCount(Long likesCount) {
    this.likesCount = likesCount;
  }


  public YoutubeVideoInfoSerpElementItem commentsCount(Long commentsCount) {
    this.commentsCount = commentsCount;
    return this;
  }

   /**
   * number of comments on the video
   * @return commentsCount
  **/
  @javax.annotation.Nullable
  public Long getCommentsCount() {
    return commentsCount;
  }

  public void setCommentsCount(Long commentsCount) {
    this.commentsCount = commentsCount;
  }


  public YoutubeVideoInfoSerpElementItem publicationDate(String publicationDate) {
    this.publicationDate = publicationDate;
    return this;
  }

   /**
   * the date when the video is published
   * @return publicationDate
  **/
  @javax.annotation.Nullable
  public String getPublicationDate() {
    return publicationDate;
  }

  public void setPublicationDate(String publicationDate) {
    this.publicationDate = publicationDate;
  }


  public YoutubeVideoInfoSerpElementItem timestamp(String timestamp) {
    this.timestamp = timestamp;
    return this;
  }

   /**
   * date and time when the result is published in the UTC format: “yyyy-mm-dd hh-mm-ss +00:00” example: 2022-11-15 12:57:46 +00:00
   * @return timestamp
  **/
  @javax.annotation.Nullable
  public String getTimestamp() {
    return timestamp;
  }

  public void setTimestamp(String timestamp) {
    this.timestamp = timestamp;
  }


  public YoutubeVideoInfoSerpElementItem keywords(List<String> keywords) {
    this.keywords = keywords;
    return this;
  }

  public YoutubeVideoInfoSerpElementItem addKeywordsItem(String keywordsItem) {
    if (this.keywords == null) {
      this.keywords = new ArrayList<>();
    }
    this.keywords.add(keywordsItem);
    return this;
  }

   /**
   * keywords relevant to the video
   * @return keywords
  **/
  @javax.annotation.Nullable
  public List<String> getKeywords() {
    return keywords;
  }

  public void setKeywords(List<String> keywords) {
    this.keywords = keywords;
  }


  public YoutubeVideoInfoSerpElementItem category(String category) {
    this.category = category;
    return this;
  }

   /**
   * the category the video belongs to
   * @return category
  **/
  @javax.annotation.Nullable
  public String getCategory() {
    return category;
  }

  public void setCategory(String category) {
    this.category = category;
  }


  public YoutubeVideoInfoSerpElementItem isLive(Boolean isLive) {
    this.isLive = isLive;
    return this;
  }

   /**
   * indicates whether the video is on live
   * @return isLive
  **/
  @javax.annotation.Nullable
  public Boolean getIsLive() {
    return isLive;
  }

  public void setIsLive(Boolean isLive) {
    this.isLive = isLive;
  }


  public YoutubeVideoInfoSerpElementItem durationTime(String durationTime) {
    this.durationTime = durationTime;
    return this;
  }

   /**
   * duration of the video
   * @return durationTime
  **/
  @javax.annotation.Nullable
  public String getDurationTime() {
    return durationTime;
  }

  public void setDurationTime(String durationTime) {
    this.durationTime = durationTime;
  }


  public YoutubeVideoInfoSerpElementItem durationTimeSeconds(Integer durationTimeSeconds) {
    this.durationTimeSeconds = durationTimeSeconds;
    return this;
  }

   /**
   * duration of the video in seconds
   * @return durationTimeSeconds
  **/
  @javax.annotation.Nullable
  public Integer getDurationTimeSeconds() {
    return durationTimeSeconds;
  }

  public void setDurationTimeSeconds(Integer durationTimeSeconds) {
    this.durationTimeSeconds = durationTimeSeconds;
  }


  public YoutubeVideoInfoSerpElementItem subtitles(List<Subtitles> subtitles) {
    this.subtitles = subtitles;
    return this;
  }

  public YoutubeVideoInfoSerpElementItem addSubtitlesItem(Subtitles subtitlesItem) {
    if (this.subtitles == null) {
      this.subtitles = new ArrayList<>();
    }
    this.subtitles.add(subtitlesItem);
    return this;
  }

   /**
   * array of elements describing properties of subtitles in the video
   * @return subtitles
  **/
  @javax.annotation.Nullable
  public List<Subtitles> getSubtitles() {
    return subtitles;
  }

  public void setSubtitles(List<Subtitles> subtitles) {
    this.subtitles = subtitles;
  }


  public YoutubeVideoInfoSerpElementItem streamingQuality(List<StreamingQualityElement> streamingQuality) {
    this.streamingQuality = streamingQuality;
    return this;
  }

  public YoutubeVideoInfoSerpElementItem addStreamingQualityItem(StreamingQualityElement streamingQualityItem) {
    if (this.streamingQuality == null) {
      this.streamingQuality = new ArrayList<>();
    }
    this.streamingQuality.add(streamingQualityItem);
    return this;
  }

   /**
   * array of elements that contain information about all possible streaming qualities of the video
   * @return streamingQuality
  **/
  @javax.annotation.Nullable
  public List<StreamingQualityElement> getStreamingQuality() {
    return streamingQuality;
  }

  public void setStreamingQuality(List<StreamingQualityElement> streamingQuality) {
    this.streamingQuality = streamingQuality;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    YoutubeVideoInfoSerpElementItem youtubeVideoInfoSerpElementItem = (YoutubeVideoInfoSerpElementItem) o;
    return Objects.equals(this.rankGroup, youtubeVideoInfoSerpElementItem.rankGroup) &&
        Objects.equals(this.rankAbsolute, youtubeVideoInfoSerpElementItem.rankAbsolute) &&
        Objects.equals(this.videoId, youtubeVideoInfoSerpElementItem.videoId) &&
        Objects.equals(this.title, youtubeVideoInfoSerpElementItem.title) &&
        Objects.equals(this.url, youtubeVideoInfoSerpElementItem.url) &&
        Objects.equals(this.thumbnailUrl, youtubeVideoInfoSerpElementItem.thumbnailUrl) &&
        Objects.equals(this.channelId, youtubeVideoInfoSerpElementItem.channelId) &&
        Objects.equals(this.channelName, youtubeVideoInfoSerpElementItem.channelName) &&
        Objects.equals(this.channelUrl, youtubeVideoInfoSerpElementItem.channelUrl) &&
        Objects.equals(this.channelLogo, youtubeVideoInfoSerpElementItem.channelLogo) &&
        Objects.equals(this.description, youtubeVideoInfoSerpElementItem.description) &&
        Objects.equals(this.viewsCount, youtubeVideoInfoSerpElementItem.viewsCount) &&
        Objects.equals(this.likesCount, youtubeVideoInfoSerpElementItem.likesCount) &&
        Objects.equals(this.commentsCount, youtubeVideoInfoSerpElementItem.commentsCount) &&
        Objects.equals(this.publicationDate, youtubeVideoInfoSerpElementItem.publicationDate) &&
        Objects.equals(this.timestamp, youtubeVideoInfoSerpElementItem.timestamp) &&
        Objects.equals(this.keywords, youtubeVideoInfoSerpElementItem.keywords) &&
        Objects.equals(this.category, youtubeVideoInfoSerpElementItem.category) &&
        Objects.equals(this.isLive, youtubeVideoInfoSerpElementItem.isLive) &&
        Objects.equals(this.durationTime, youtubeVideoInfoSerpElementItem.durationTime) &&
        Objects.equals(this.durationTimeSeconds, youtubeVideoInfoSerpElementItem.durationTimeSeconds) &&
        Objects.equals(this.subtitles, youtubeVideoInfoSerpElementItem.subtitles) &&
        Objects.equals(this.streamingQuality, youtubeVideoInfoSerpElementItem.streamingQuality) &&
        super.equals(o);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(rankGroup, rankAbsolute, videoId, title, url, thumbnailUrl, channelId, channelName, channelUrl, channelLogo, description, viewsCount, likesCount, commentsCount, publicationDate, timestamp, keywords, category, isLive, durationTime, durationTimeSeconds, subtitles, streamingQuality, super.hashCode());
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class YoutubeVideoInfoSerpElementItem {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    rankGroup: ").append(toIndentedString(rankGroup)).append("\n");
    sb.append("    rankAbsolute: ").append(toIndentedString(rankAbsolute)).append("\n");
    sb.append("    videoId: ").append(toIndentedString(videoId)).append("\n");
    sb.append("    title: ").append(toIndentedString(title)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("    thumbnailUrl: ").append(toIndentedString(thumbnailUrl)).append("\n");
    sb.append("    channelId: ").append(toIndentedString(channelId)).append("\n");
    sb.append("    channelName: ").append(toIndentedString(channelName)).append("\n");
    sb.append("    channelUrl: ").append(toIndentedString(channelUrl)).append("\n");
    sb.append("    channelLogo: ").append(toIndentedString(channelLogo)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    viewsCount: ").append(toIndentedString(viewsCount)).append("\n");
    sb.append("    likesCount: ").append(toIndentedString(likesCount)).append("\n");
    sb.append("    commentsCount: ").append(toIndentedString(commentsCount)).append("\n");
    sb.append("    publicationDate: ").append(toIndentedString(publicationDate)).append("\n");
    sb.append("    timestamp: ").append(toIndentedString(timestamp)).append("\n");
    sb.append("    keywords: ").append(toIndentedString(keywords)).append("\n");
    sb.append("    category: ").append(toIndentedString(category)).append("\n");
    sb.append("    isLive: ").append(toIndentedString(isLive)).append("\n");
    sb.append("    durationTime: ").append(toIndentedString(durationTime)).append("\n");
    sb.append("    durationTimeSeconds: ").append(toIndentedString(durationTimeSeconds)).append("\n");
    sb.append("    subtitles: ").append(toIndentedString(subtitles)).append("\n");
    sb.append("    streamingQuality: ").append(toIndentedString(streamingQuality)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("type");
    openapiFields.add("rank_group");
    openapiFields.add("rank_absolute");
    openapiFields.add("video_id");
    openapiFields.add("title");
    openapiFields.add("url");
    openapiFields.add("thumbnail_url");
    openapiFields.add("channel_id");
    openapiFields.add("channel_name");
    openapiFields.add("channel_url");
    openapiFields.add("channel_logo");
    openapiFields.add("description");
    openapiFields.add("views_count");
    openapiFields.add("likes_count");
    openapiFields.add("comments_count");
    openapiFields.add("publication_date");
    openapiFields.add("timestamp");
    openapiFields.add("keywords");
    openapiFields.add("category");
    openapiFields.add("is_live");
    openapiFields.add("duration_time");
    openapiFields.add("duration_time_seconds");
    openapiFields.add("subtitles");
    openapiFields.add("streaming_quality");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to YoutubeVideoInfoSerpElementItem
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!YoutubeVideoInfoSerpElementItem.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in YoutubeVideoInfoSerpElementItem is not found in the empty JSON string", YoutubeVideoInfoSerpElementItem.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!YoutubeVideoInfoSerpElementItem.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `YoutubeVideoInfoSerpElementItem` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!YoutubeVideoInfoSerpElementItem.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'YoutubeVideoInfoSerpElementItem' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<YoutubeVideoInfoSerpElementItem> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(YoutubeVideoInfoSerpElementItem.class));

       return (TypeAdapter<T>) new TypeAdapter<YoutubeVideoInfoSerpElementItem>() {
           @Override
           public void write(JsonWriter out, YoutubeVideoInfoSerpElementItem value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public YoutubeVideoInfoSerpElementItem read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of YoutubeVideoInfoSerpElementItem given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of YoutubeVideoInfoSerpElementItem
  * @throws IOException if the JSON string is invalid with respect to YoutubeVideoInfoSerpElementItem
  */
  public static YoutubeVideoInfoSerpElementItem fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, YoutubeVideoInfoSerpElementItem.class);
  }

 /**
  * Convert an instance of YoutubeVideoInfoSerpElementItem to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

