/*
 * DataForSEO API documentation
 * DataForSEO API is the starting point on your journey towards building powerful SEO software. With DataForSEO you can get all the data you need to build an efficient application while also saving your time and budget. DataForSEO API is using the REST technology for interchanging data between your application and our service. The data exchange is made through the widely used HTTP protocol, which allows applying our API to almost all programming languages.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.dataforseo.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.dataforseo.client.model.BaseOnPageLinkItemInfo;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.dataforseo.client.JSON;

/**
 * ImageLinkElementItem
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-06-02T20:51:42.343286900+03:00[Europe/Kiev]")
public class ImageLinkElementItem extends BaseOnPageLinkItemInfo {
  public static final String SERIALIZED_NAME_DOMAIN_FROM = "domain_from";
  @SerializedName(SERIALIZED_NAME_DOMAIN_FROM)
  private String domainFrom;

  public static final String SERIALIZED_NAME_DOMAIN_TO = "domain_to";
  @SerializedName(SERIALIZED_NAME_DOMAIN_TO)
  private String domainTo;

  public static final String SERIALIZED_NAME_PAGE_FROM = "page_from";
  @SerializedName(SERIALIZED_NAME_PAGE_FROM)
  private String pageFrom;

  public static final String SERIALIZED_NAME_PAGE_TO = "page_to";
  @SerializedName(SERIALIZED_NAME_PAGE_TO)
  private String pageTo;

  public static final String SERIALIZED_NAME_LINK_FROM = "link_from";
  @SerializedName(SERIALIZED_NAME_LINK_FROM)
  private String linkFrom;

  public static final String SERIALIZED_NAME_LINK_TO = "link_to";
  @SerializedName(SERIALIZED_NAME_LINK_TO)
  private String linkTo;

  public static final String SERIALIZED_NAME_LINK_ATTRIBUTE = "link_attribute";
  @SerializedName(SERIALIZED_NAME_LINK_ATTRIBUTE)
  private List<String> linkAttribute;

  public static final String SERIALIZED_NAME_DOFOLLOW = "dofollow";
  @SerializedName(SERIALIZED_NAME_DOFOLLOW)
  private Boolean dofollow;

  public static final String SERIALIZED_NAME_PAGE_FROM_SCHEME = "page_from_scheme";
  @SerializedName(SERIALIZED_NAME_PAGE_FROM_SCHEME)
  private String pageFromScheme;

  public static final String SERIALIZED_NAME_PAGE_TO_SCHEME = "page_to_scheme";
  @SerializedName(SERIALIZED_NAME_PAGE_TO_SCHEME)
  private String pageToScheme;

  public static final String SERIALIZED_NAME_DIRECTION = "direction";
  @SerializedName(SERIALIZED_NAME_DIRECTION)
  private String direction;

  public static final String SERIALIZED_NAME_IS_BROKEN = "is_broken";
  @SerializedName(SERIALIZED_NAME_IS_BROKEN)
  private Boolean isBroken;

  public static final String SERIALIZED_NAME_TEXT = "text";
  @SerializedName(SERIALIZED_NAME_TEXT)
  private String text;

  public static final String SERIALIZED_NAME_IMAGE_ALT = "image_alt";
  @SerializedName(SERIALIZED_NAME_IMAGE_ALT)
  private String imageAlt;

  public static final String SERIALIZED_NAME_IMAGE_SRC = "image_src";
  @SerializedName(SERIALIZED_NAME_IMAGE_SRC)
  private String imageSrc;

  public static final String SERIALIZED_NAME_IS_LINK_RELATION_CONFLICT = "is_link_relation_conflict";
  @SerializedName(SERIALIZED_NAME_IS_LINK_RELATION_CONFLICT)
  private Boolean isLinkRelationConflict;

  public static final String SERIALIZED_NAME_PAGE_TO_STATUS_CODE = "page_to_status_code";
  @SerializedName(SERIALIZED_NAME_PAGE_TO_STATUS_CODE)
  private Integer pageToStatusCode;

  public ImageLinkElementItem() {
    this.type = this.getClass().getSimpleName();
  }

  public ImageLinkElementItem domainFrom(String domainFrom) {
    this.domainFrom = domainFrom;
    return this;
  }

   /**
   * referring domain the link was found on this domain
   * @return domainFrom
  **/
  @javax.annotation.Nullable
  public String getDomainFrom() {
    return domainFrom;
  }

  public void setDomainFrom(String domainFrom) {
    this.domainFrom = domainFrom;
  }


  public ImageLinkElementItem domainTo(String domainTo) {
    this.domainTo = domainTo;
    return this;
  }

   /**
   * referenced domain the link is pointing to this domain
   * @return domainTo
  **/
  @javax.annotation.Nullable
  public String getDomainTo() {
    return domainTo;
  }

  public void setDomainTo(String domainTo) {
    this.domainTo = domainTo;
  }


  public ImageLinkElementItem pageFrom(String pageFrom) {
    this.pageFrom = pageFrom;
    return this;
  }

   /**
   * referring page relative URL of the page on which the link was found
   * @return pageFrom
  **/
  @javax.annotation.Nullable
  public String getPageFrom() {
    return pageFrom;
  }

  public void setPageFrom(String pageFrom) {
    this.pageFrom = pageFrom;
  }


  public ImageLinkElementItem pageTo(String pageTo) {
    this.pageTo = pageTo;
    return this;
  }

   /**
   * referenced page relative URL of the page to which the link is pointing
   * @return pageTo
  **/
  @javax.annotation.Nullable
  public String getPageTo() {
    return pageTo;
  }

  public void setPageTo(String pageTo) {
    this.pageTo = pageTo;
  }


  public ImageLinkElementItem linkFrom(String linkFrom) {
    this.linkFrom = linkFrom;
    return this;
  }

   /**
   * referring page absolute URL of the page on which the link was found
   * @return linkFrom
  **/
  @javax.annotation.Nullable
  public String getLinkFrom() {
    return linkFrom;
  }

  public void setLinkFrom(String linkFrom) {
    this.linkFrom = linkFrom;
  }


  public ImageLinkElementItem linkTo(String linkTo) {
    this.linkTo = linkTo;
    return this;
  }

   /**
   * referenced page absolute URL of the page to which the link is pointing
   * @return linkTo
  **/
  @javax.annotation.Nullable
  public String getLinkTo() {
    return linkTo;
  }

  public void setLinkTo(String linkTo) {
    this.linkTo = linkTo;
  }


  public ImageLinkElementItem linkAttribute(List<String> linkAttribute) {
    this.linkAttribute = linkAttribute;
    return this;
  }

  public ImageLinkElementItem addLinkAttributeItem(String linkAttributeItem) {
    if (this.linkAttribute == null) {
      this.linkAttribute = new ArrayList<>();
    }
    this.linkAttribute.add(linkAttributeItem);
    return this;
  }

   /**
   * link attribute added to external link indicates link attributes added to the link_to on the page_from example: [\&quot;ugc\&quot;,\&quot;noopener\&quot;]
   * @return linkAttribute
  **/
  @javax.annotation.Nullable
  public List<String> getLinkAttribute() {
    return linkAttribute;
  }

  public void setLinkAttribute(List<String> linkAttribute) {
    this.linkAttribute = linkAttribute;
  }


  public ImageLinkElementItem dofollow(Boolean dofollow) {
    this.dofollow = dofollow;
    return this;
  }

   /**
   * indicates whether the link is dofollow if the value is true, the link doesnâ€™t have a rel&#x3D;\&quot;nofollow\&quot; attribute
   * @return dofollow
  **/
  @javax.annotation.Nullable
  public Boolean getDofollow() {
    return dofollow;
  }

  public void setDofollow(Boolean dofollow) {
    this.dofollow = dofollow;
  }


  public ImageLinkElementItem pageFromScheme(String pageFromScheme) {
    this.pageFromScheme = pageFromScheme;
    return this;
  }

   /**
   * url scheme of the referring page
   * @return pageFromScheme
  **/
  @javax.annotation.Nullable
  public String getPageFromScheme() {
    return pageFromScheme;
  }

  public void setPageFromScheme(String pageFromScheme) {
    this.pageFromScheme = pageFromScheme;
  }


  public ImageLinkElementItem pageToScheme(String pageToScheme) {
    this.pageToScheme = pageToScheme;
    return this;
  }

   /**
   * url scheme of the referenced page
   * @return pageToScheme
  **/
  @javax.annotation.Nullable
  public String getPageToScheme() {
    return pageToScheme;
  }

  public void setPageToScheme(String pageToScheme) {
    this.pageToScheme = pageToScheme;
  }


  public ImageLinkElementItem direction(String direction) {
    this.direction = direction;
    return this;
  }

   /**
   * direction of the link possible values: internal, external
   * @return direction
  **/
  @javax.annotation.Nullable
  public String getDirection() {
    return direction;
  }

  public void setDirection(String direction) {
    this.direction = direction;
  }


  public ImageLinkElementItem isBroken(Boolean isBroken) {
    this.isBroken = isBroken;
    return this;
  }

   /**
   * link is broken indicates whether a link is directing to a broken page or resource
   * @return isBroken
  **/
  @javax.annotation.Nullable
  public Boolean getIsBroken() {
    return isBroken;
  }

  public void setIsBroken(Boolean isBroken) {
    this.isBroken = isBroken;
  }


  public ImageLinkElementItem text(String text) {
    this.text = text;
    return this;
  }

   /**
   * anchor text
   * @return text
  **/
  @javax.annotation.Nullable
  public String getText() {
    return text;
  }

  public void setText(String text) {
    this.text = text;
  }


  public ImageLinkElementItem imageAlt(String imageAlt) {
    this.imageAlt = imageAlt;
    return this;
  }

   /**
   * alternative text for the image
   * @return imageAlt
  **/
  @javax.annotation.Nullable
  public String getImageAlt() {
    return imageAlt;
  }

  public void setImageAlt(String imageAlt) {
    this.imageAlt = imageAlt;
  }


  public ImageLinkElementItem imageSrc(String imageSrc) {
    this.imageSrc = imageSrc;
    return this;
  }

   /**
   * url of the image
   * @return imageSrc
  **/
  @javax.annotation.Nullable
  public String getImageSrc() {
    return imageSrc;
  }

  public void setImageSrc(String imageSrc) {
    this.imageSrc = imageSrc;
  }


  public ImageLinkElementItem isLinkRelationConflict(Boolean isLinkRelationConflict) {
    this.isLinkRelationConflict = isLinkRelationConflict;
    return this;
  }

   /**
   * indicates that the link may have a conflict with another link if true, at least one link pointing to link_to has a rel&#x3D;\&quot;nofollow\&quot; attribute and at least one is dofollow
   * @return isLinkRelationConflict
  **/
  @javax.annotation.Nullable
  public Boolean getIsLinkRelationConflict() {
    return isLinkRelationConflict;
  }

  public void setIsLinkRelationConflict(Boolean isLinkRelationConflict) {
    this.isLinkRelationConflict = isLinkRelationConflict;
  }


  public ImageLinkElementItem pageToStatusCode(Integer pageToStatusCode) {
    this.pageToStatusCode = pageToStatusCode;
    return this;
  }

   /**
   * status code of the referenced page status code of the page to which the link is pointing
   * @return pageToStatusCode
  **/
  @javax.annotation.Nullable
  public Integer getPageToStatusCode() {
    return pageToStatusCode;
  }

  public void setPageToStatusCode(Integer pageToStatusCode) {
    this.pageToStatusCode = pageToStatusCode;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ImageLinkElementItem imageLinkElementItem = (ImageLinkElementItem) o;
    return Objects.equals(this.domainFrom, imageLinkElementItem.domainFrom) &&
        Objects.equals(this.domainTo, imageLinkElementItem.domainTo) &&
        Objects.equals(this.pageFrom, imageLinkElementItem.pageFrom) &&
        Objects.equals(this.pageTo, imageLinkElementItem.pageTo) &&
        Objects.equals(this.linkFrom, imageLinkElementItem.linkFrom) &&
        Objects.equals(this.linkTo, imageLinkElementItem.linkTo) &&
        Objects.equals(this.linkAttribute, imageLinkElementItem.linkAttribute) &&
        Objects.equals(this.dofollow, imageLinkElementItem.dofollow) &&
        Objects.equals(this.pageFromScheme, imageLinkElementItem.pageFromScheme) &&
        Objects.equals(this.pageToScheme, imageLinkElementItem.pageToScheme) &&
        Objects.equals(this.direction, imageLinkElementItem.direction) &&
        Objects.equals(this.isBroken, imageLinkElementItem.isBroken) &&
        Objects.equals(this.text, imageLinkElementItem.text) &&
        Objects.equals(this.imageAlt, imageLinkElementItem.imageAlt) &&
        Objects.equals(this.imageSrc, imageLinkElementItem.imageSrc) &&
        Objects.equals(this.isLinkRelationConflict, imageLinkElementItem.isLinkRelationConflict) &&
        Objects.equals(this.pageToStatusCode, imageLinkElementItem.pageToStatusCode) &&
        super.equals(o);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(domainFrom, domainTo, pageFrom, pageTo, linkFrom, linkTo, linkAttribute, dofollow, pageFromScheme, pageToScheme, direction, isBroken, text, imageAlt, imageSrc, isLinkRelationConflict, pageToStatusCode, super.hashCode());
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ImageLinkElementItem {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    domainFrom: ").append(toIndentedString(domainFrom)).append("\n");
    sb.append("    domainTo: ").append(toIndentedString(domainTo)).append("\n");
    sb.append("    pageFrom: ").append(toIndentedString(pageFrom)).append("\n");
    sb.append("    pageTo: ").append(toIndentedString(pageTo)).append("\n");
    sb.append("    linkFrom: ").append(toIndentedString(linkFrom)).append("\n");
    sb.append("    linkTo: ").append(toIndentedString(linkTo)).append("\n");
    sb.append("    linkAttribute: ").append(toIndentedString(linkAttribute)).append("\n");
    sb.append("    dofollow: ").append(toIndentedString(dofollow)).append("\n");
    sb.append("    pageFromScheme: ").append(toIndentedString(pageFromScheme)).append("\n");
    sb.append("    pageToScheme: ").append(toIndentedString(pageToScheme)).append("\n");
    sb.append("    direction: ").append(toIndentedString(direction)).append("\n");
    sb.append("    isBroken: ").append(toIndentedString(isBroken)).append("\n");
    sb.append("    text: ").append(toIndentedString(text)).append("\n");
    sb.append("    imageAlt: ").append(toIndentedString(imageAlt)).append("\n");
    sb.append("    imageSrc: ").append(toIndentedString(imageSrc)).append("\n");
    sb.append("    isLinkRelationConflict: ").append(toIndentedString(isLinkRelationConflict)).append("\n");
    sb.append("    pageToStatusCode: ").append(toIndentedString(pageToStatusCode)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("type");
    openapiFields.add("domain_from");
    openapiFields.add("domain_to");
    openapiFields.add("page_from");
    openapiFields.add("page_to");
    openapiFields.add("link_from");
    openapiFields.add("link_to");
    openapiFields.add("link_attribute");
    openapiFields.add("dofollow");
    openapiFields.add("page_from_scheme");
    openapiFields.add("page_to_scheme");
    openapiFields.add("direction");
    openapiFields.add("is_broken");
    openapiFields.add("text");
    openapiFields.add("image_alt");
    openapiFields.add("image_src");
    openapiFields.add("is_link_relation_conflict");
    openapiFields.add("page_to_status_code");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to ImageLinkElementItem
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ImageLinkElementItem.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ImageLinkElementItem is not found in the empty JSON string", ImageLinkElementItem.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ImageLinkElementItem.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ImageLinkElementItem` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ImageLinkElementItem.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ImageLinkElementItem' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ImageLinkElementItem> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ImageLinkElementItem.class));

       return (TypeAdapter<T>) new TypeAdapter<ImageLinkElementItem>() {
           @Override
           public void write(JsonWriter out, ImageLinkElementItem value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ImageLinkElementItem read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of ImageLinkElementItem given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ImageLinkElementItem
  * @throws IOException if the JSON string is invalid with respect to ImageLinkElementItem
  */
  public static ImageLinkElementItem fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ImageLinkElementItem.class);
  }

 /**
  * Convert an instance of ImageLinkElementItem to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

