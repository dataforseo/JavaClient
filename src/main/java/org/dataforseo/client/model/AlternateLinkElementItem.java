/*
 * DataForSEO API documentation
 * DataForSEO API is the starting point on your journey towards building powerful SEO software. With DataForSEO you can get all the data you need to build an efficient application while also saving your time and budget. DataForSEO API is using the REST technology for interchanging data between your application and our service. The data exchange is made through the widely used HTTP protocol, which allows applying our API to almost all programming languages.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.dataforseo.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.dataforseo.client.model.BaseOnPageLinkItemInfo;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.dataforseo.client.JSON;

/**
 * AlternateLinkElementItem
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-06-02T18:32:56.856102800+03:00[Europe/Kiev]")
public class AlternateLinkElementItem extends BaseOnPageLinkItemInfo {
  public static final String SERIALIZED_NAME_DOMAIN_FROM = "domain_from";
  @SerializedName(SERIALIZED_NAME_DOMAIN_FROM)
  private String domainFrom;

  public static final String SERIALIZED_NAME_DOMAIN_TO = "domain_to";
  @SerializedName(SERIALIZED_NAME_DOMAIN_TO)
  private String domainTo;

  public static final String SERIALIZED_NAME_PAGE_FROM = "page_from";
  @SerializedName(SERIALIZED_NAME_PAGE_FROM)
  private String pageFrom;

  public static final String SERIALIZED_NAME_PAGE_TO = "page_to";
  @SerializedName(SERIALIZED_NAME_PAGE_TO)
  private String pageTo;

  public static final String SERIALIZED_NAME_LINK_FROM = "link_from";
  @SerializedName(SERIALIZED_NAME_LINK_FROM)
  private String linkFrom;

  public static final String SERIALIZED_NAME_LINK_TO = "link_to";
  @SerializedName(SERIALIZED_NAME_LINK_TO)
  private String linkTo;

  public static final String SERIALIZED_NAME_DOFOLLOW = "dofollow";
  @SerializedName(SERIALIZED_NAME_DOFOLLOW)
  private Boolean dofollow;

  public static final String SERIALIZED_NAME_PAGE_FROM_SCHEME = "page_from_scheme";
  @SerializedName(SERIALIZED_NAME_PAGE_FROM_SCHEME)
  private String pageFromScheme;

  public static final String SERIALIZED_NAME_PAGE_TO_SCHEME = "page_to_scheme";
  @SerializedName(SERIALIZED_NAME_PAGE_TO_SCHEME)
  private String pageToScheme;

  public static final String SERIALIZED_NAME_DIRECTION = "direction";
  @SerializedName(SERIALIZED_NAME_DIRECTION)
  private String direction;

  public static final String SERIALIZED_NAME_IS_BROKEN = "is_broken";
  @SerializedName(SERIALIZED_NAME_IS_BROKEN)
  private Boolean isBroken;

  public static final String SERIALIZED_NAME_IS_LINK_RELATION_CONFLICT = "is_link_relation_conflict";
  @SerializedName(SERIALIZED_NAME_IS_LINK_RELATION_CONFLICT)
  private Boolean isLinkRelationConflict;

  public static final String SERIALIZED_NAME_PAGE_TO_STATUS_CODE = "page_to_status_code";
  @SerializedName(SERIALIZED_NAME_PAGE_TO_STATUS_CODE)
  private Integer pageToStatusCode;

  public AlternateLinkElementItem() {
    this.type = this.getClass().getSimpleName();
  }

  public AlternateLinkElementItem domainFrom(String domainFrom) {
    this.domainFrom = domainFrom;
    return this;
  }

   /**
   * referring domain the link was found on this domain
   * @return domainFrom
  **/
  @javax.annotation.Nullable
  public String getDomainFrom() {
    return domainFrom;
  }

  public void setDomainFrom(String domainFrom) {
    this.domainFrom = domainFrom;
  }


  public AlternateLinkElementItem domainTo(String domainTo) {
    this.domainTo = domainTo;
    return this;
  }

   /**
   * referenced domain the link is pointing to this domain
   * @return domainTo
  **/
  @javax.annotation.Nullable
  public String getDomainTo() {
    return domainTo;
  }

  public void setDomainTo(String domainTo) {
    this.domainTo = domainTo;
  }


  public AlternateLinkElementItem pageFrom(String pageFrom) {
    this.pageFrom = pageFrom;
    return this;
  }

   /**
   * referring page relative URL of the page on which the link was found
   * @return pageFrom
  **/
  @javax.annotation.Nullable
  public String getPageFrom() {
    return pageFrom;
  }

  public void setPageFrom(String pageFrom) {
    this.pageFrom = pageFrom;
  }


  public AlternateLinkElementItem pageTo(String pageTo) {
    this.pageTo = pageTo;
    return this;
  }

   /**
   * referenced page relative URL of the page to which the link is pointing
   * @return pageTo
  **/
  @javax.annotation.Nullable
  public String getPageTo() {
    return pageTo;
  }

  public void setPageTo(String pageTo) {
    this.pageTo = pageTo;
  }


  public AlternateLinkElementItem linkFrom(String linkFrom) {
    this.linkFrom = linkFrom;
    return this;
  }

   /**
   * referring page absolute URL of the page on which the link was found
   * @return linkFrom
  **/
  @javax.annotation.Nullable
  public String getLinkFrom() {
    return linkFrom;
  }

  public void setLinkFrom(String linkFrom) {
    this.linkFrom = linkFrom;
  }


  public AlternateLinkElementItem linkTo(String linkTo) {
    this.linkTo = linkTo;
    return this;
  }

   /**
   * referenced page absolute URL of the page to which the link is pointing
   * @return linkTo
  **/
  @javax.annotation.Nullable
  public String getLinkTo() {
    return linkTo;
  }

  public void setLinkTo(String linkTo) {
    this.linkTo = linkTo;
  }


  public AlternateLinkElementItem dofollow(Boolean dofollow) {
    this.dofollow = dofollow;
    return this;
  }

   /**
   * indicates whether the link is dofollow if the value is true, the link doesnâ€™t have a rel&#x3D;\&quot;nofollow\&quot; attribute
   * @return dofollow
  **/
  @javax.annotation.Nullable
  public Boolean getDofollow() {
    return dofollow;
  }

  public void setDofollow(Boolean dofollow) {
    this.dofollow = dofollow;
  }


  public AlternateLinkElementItem pageFromScheme(String pageFromScheme) {
    this.pageFromScheme = pageFromScheme;
    return this;
  }

   /**
   * url scheme of the referring page
   * @return pageFromScheme
  **/
  @javax.annotation.Nullable
  public String getPageFromScheme() {
    return pageFromScheme;
  }

  public void setPageFromScheme(String pageFromScheme) {
    this.pageFromScheme = pageFromScheme;
  }


  public AlternateLinkElementItem pageToScheme(String pageToScheme) {
    this.pageToScheme = pageToScheme;
    return this;
  }

   /**
   * url scheme of the referenced page
   * @return pageToScheme
  **/
  @javax.annotation.Nullable
  public String getPageToScheme() {
    return pageToScheme;
  }

  public void setPageToScheme(String pageToScheme) {
    this.pageToScheme = pageToScheme;
  }


  public AlternateLinkElementItem direction(String direction) {
    this.direction = direction;
    return this;
  }

   /**
   * direction of the link possible values: internal, external
   * @return direction
  **/
  @javax.annotation.Nullable
  public String getDirection() {
    return direction;
  }

  public void setDirection(String direction) {
    this.direction = direction;
  }


  public AlternateLinkElementItem isBroken(Boolean isBroken) {
    this.isBroken = isBroken;
    return this;
  }

   /**
   * link is broken indicates whether a link is directing to a broken page or resource
   * @return isBroken
  **/
  @javax.annotation.Nullable
  public Boolean getIsBroken() {
    return isBroken;
  }

  public void setIsBroken(Boolean isBroken) {
    this.isBroken = isBroken;
  }


  public AlternateLinkElementItem isLinkRelationConflict(Boolean isLinkRelationConflict) {
    this.isLinkRelationConflict = isLinkRelationConflict;
    return this;
  }

   /**
   * indicates that the link may have a conflict with another link if true, at least one link pointing to link_to has a rel&#x3D;\&quot;nofollow\&quot; attribute and at least one is dofollow
   * @return isLinkRelationConflict
  **/
  @javax.annotation.Nullable
  public Boolean getIsLinkRelationConflict() {
    return isLinkRelationConflict;
  }

  public void setIsLinkRelationConflict(Boolean isLinkRelationConflict) {
    this.isLinkRelationConflict = isLinkRelationConflict;
  }


  public AlternateLinkElementItem pageToStatusCode(Integer pageToStatusCode) {
    this.pageToStatusCode = pageToStatusCode;
    return this;
  }

   /**
   * status code of the referenced page status code of the page to which the link is pointing
   * @return pageToStatusCode
  **/
  @javax.annotation.Nullable
  public Integer getPageToStatusCode() {
    return pageToStatusCode;
  }

  public void setPageToStatusCode(Integer pageToStatusCode) {
    this.pageToStatusCode = pageToStatusCode;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AlternateLinkElementItem alternateLinkElementItem = (AlternateLinkElementItem) o;
    return Objects.equals(this.domainFrom, alternateLinkElementItem.domainFrom) &&
        Objects.equals(this.domainTo, alternateLinkElementItem.domainTo) &&
        Objects.equals(this.pageFrom, alternateLinkElementItem.pageFrom) &&
        Objects.equals(this.pageTo, alternateLinkElementItem.pageTo) &&
        Objects.equals(this.linkFrom, alternateLinkElementItem.linkFrom) &&
        Objects.equals(this.linkTo, alternateLinkElementItem.linkTo) &&
        Objects.equals(this.dofollow, alternateLinkElementItem.dofollow) &&
        Objects.equals(this.pageFromScheme, alternateLinkElementItem.pageFromScheme) &&
        Objects.equals(this.pageToScheme, alternateLinkElementItem.pageToScheme) &&
        Objects.equals(this.direction, alternateLinkElementItem.direction) &&
        Objects.equals(this.isBroken, alternateLinkElementItem.isBroken) &&
        Objects.equals(this.isLinkRelationConflict, alternateLinkElementItem.isLinkRelationConflict) &&
        Objects.equals(this.pageToStatusCode, alternateLinkElementItem.pageToStatusCode) &&
        super.equals(o);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(domainFrom, domainTo, pageFrom, pageTo, linkFrom, linkTo, dofollow, pageFromScheme, pageToScheme, direction, isBroken, isLinkRelationConflict, pageToStatusCode, super.hashCode());
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AlternateLinkElementItem {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    domainFrom: ").append(toIndentedString(domainFrom)).append("\n");
    sb.append("    domainTo: ").append(toIndentedString(domainTo)).append("\n");
    sb.append("    pageFrom: ").append(toIndentedString(pageFrom)).append("\n");
    sb.append("    pageTo: ").append(toIndentedString(pageTo)).append("\n");
    sb.append("    linkFrom: ").append(toIndentedString(linkFrom)).append("\n");
    sb.append("    linkTo: ").append(toIndentedString(linkTo)).append("\n");
    sb.append("    dofollow: ").append(toIndentedString(dofollow)).append("\n");
    sb.append("    pageFromScheme: ").append(toIndentedString(pageFromScheme)).append("\n");
    sb.append("    pageToScheme: ").append(toIndentedString(pageToScheme)).append("\n");
    sb.append("    direction: ").append(toIndentedString(direction)).append("\n");
    sb.append("    isBroken: ").append(toIndentedString(isBroken)).append("\n");
    sb.append("    isLinkRelationConflict: ").append(toIndentedString(isLinkRelationConflict)).append("\n");
    sb.append("    pageToStatusCode: ").append(toIndentedString(pageToStatusCode)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("type");
    openapiFields.add("domain_from");
    openapiFields.add("domain_to");
    openapiFields.add("page_from");
    openapiFields.add("page_to");
    openapiFields.add("link_from");
    openapiFields.add("link_to");
    openapiFields.add("dofollow");
    openapiFields.add("page_from_scheme");
    openapiFields.add("page_to_scheme");
    openapiFields.add("direction");
    openapiFields.add("is_broken");
    openapiFields.add("is_link_relation_conflict");
    openapiFields.add("page_to_status_code");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to AlternateLinkElementItem
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!AlternateLinkElementItem.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AlternateLinkElementItem is not found in the empty JSON string", AlternateLinkElementItem.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!AlternateLinkElementItem.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `AlternateLinkElementItem` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AlternateLinkElementItem.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AlternateLinkElementItem' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AlternateLinkElementItem> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AlternateLinkElementItem.class));

       return (TypeAdapter<T>) new TypeAdapter<AlternateLinkElementItem>() {
           @Override
           public void write(JsonWriter out, AlternateLinkElementItem value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AlternateLinkElementItem read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of AlternateLinkElementItem given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of AlternateLinkElementItem
  * @throws IOException if the JSON string is invalid with respect to AlternateLinkElementItem
  */
  public static AlternateLinkElementItem fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AlternateLinkElementItem.class);
  }

 /**
  * Convert an instance of AlternateLinkElementItem to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

