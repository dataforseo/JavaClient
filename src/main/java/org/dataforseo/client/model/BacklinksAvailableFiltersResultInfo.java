/*
 * DataForSEO API documentation
 * DataForSEO API is the starting point on your journey towards building powerful SEO software. With DataForSEO you can get all the data you need to build an efficient application while also saving your time and budget. DataForSEO API is using the REST technology for interchanging data between your application and our service. The data exchange is made through the widely used HTTP protocol, which allows applying our API to almost all programming languages.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.dataforseo.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.dataforseo.client.JSON;

/**
 * BacklinksAvailableFiltersResultInfo
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-04-15T10:15:18.753898100+03:00[Europe/Kiev]")
public class BacklinksAvailableFiltersResultInfo {
  public static final String SERIALIZED_NAME_CONTENT_DUPLICATES = "content_duplicates";
  @SerializedName(SERIALIZED_NAME_CONTENT_DUPLICATES)
  private Map<String, String> contentDuplicates;

  public static final String SERIALIZED_NAME_BACKLINKS = "backlinks";
  @SerializedName(SERIALIZED_NAME_BACKLINKS)
  private Map<String, String> backlinks;

  public static final String SERIALIZED_NAME_DOMAIN_PAGES = "domain_pages";
  @SerializedName(SERIALIZED_NAME_DOMAIN_PAGES)
  private Map<String, String> domainPages;

  public static final String SERIALIZED_NAME_ANCHORS = "anchors";
  @SerializedName(SERIALIZED_NAME_ANCHORS)
  private Map<String, String> anchors;

  public static final String SERIALIZED_NAME_REFERRING_DOMAINS = "referring_domains";
  @SerializedName(SERIALIZED_NAME_REFERRING_DOMAINS)
  private Map<String, String> referringDomains;

  public static final String SERIALIZED_NAME_DOMAIN_INTERSECTION = "domain_intersection";
  @SerializedName(SERIALIZED_NAME_DOMAIN_INTERSECTION)
  private Map<String, String> domainIntersection;

  public static final String SERIALIZED_NAME_PAGE_INTERSECTION = "page_intersection";
  @SerializedName(SERIALIZED_NAME_PAGE_INTERSECTION)
  private Map<String, String> pageIntersection;

  public static final String SERIALIZED_NAME_REFERRING_NETWORKS = "referring_networks";
  @SerializedName(SERIALIZED_NAME_REFERRING_NETWORKS)
  private Map<String, String> referringNetworks;

  public static final String SERIALIZED_NAME_DOMAIN_PAGES_SUMMARY = "domain_pages_summary";
  @SerializedName(SERIALIZED_NAME_DOMAIN_PAGES_SUMMARY)
  private Map<String, String> domainPagesSummary;

  public static final String SERIALIZED_NAME_COMPETITORS = "competitors";
  @SerializedName(SERIALIZED_NAME_COMPETITORS)
  private Map<String, String> competitors;

  public BacklinksAvailableFiltersResultInfo() {
  }

  public BacklinksAvailableFiltersResultInfo contentDuplicates(Map<String, String> contentDuplicates) {
    this.contentDuplicates = contentDuplicates;
    return this;
  }

  public BacklinksAvailableFiltersResultInfo putContentDuplicatesItem(String key, String contentDuplicatesItem) {
    if (this.contentDuplicates == null) {
      this.contentDuplicates = new HashMap<>();
    }
    this.contentDuplicates.put(key, contentDuplicatesItem);
    return this;
  }

   /**
   * Get contentDuplicates
   * @return contentDuplicates
  **/
  @javax.annotation.Nullable
  public Map<String, String> getContentDuplicates() {
    return contentDuplicates;
  }

  public void setContentDuplicates(Map<String, String> contentDuplicates) {
    this.contentDuplicates = contentDuplicates;
  }


  public BacklinksAvailableFiltersResultInfo backlinks(Map<String, String> backlinks) {
    this.backlinks = backlinks;
    return this;
  }

  public BacklinksAvailableFiltersResultInfo putBacklinksItem(String key, String backlinksItem) {
    if (this.backlinks == null) {
      this.backlinks = new HashMap<>();
    }
    this.backlinks.put(key, backlinksItem);
    return this;
  }

   /**
   * Get backlinks
   * @return backlinks
  **/
  @javax.annotation.Nullable
  public Map<String, String> getBacklinks() {
    return backlinks;
  }

  public void setBacklinks(Map<String, String> backlinks) {
    this.backlinks = backlinks;
  }


  public BacklinksAvailableFiltersResultInfo domainPages(Map<String, String> domainPages) {
    this.domainPages = domainPages;
    return this;
  }

  public BacklinksAvailableFiltersResultInfo putDomainPagesItem(String key, String domainPagesItem) {
    if (this.domainPages == null) {
      this.domainPages = new HashMap<>();
    }
    this.domainPages.put(key, domainPagesItem);
    return this;
  }

   /**
   * Get domainPages
   * @return domainPages
  **/
  @javax.annotation.Nullable
  public Map<String, String> getDomainPages() {
    return domainPages;
  }

  public void setDomainPages(Map<String, String> domainPages) {
    this.domainPages = domainPages;
  }


  public BacklinksAvailableFiltersResultInfo anchors(Map<String, String> anchors) {
    this.anchors = anchors;
    return this;
  }

  public BacklinksAvailableFiltersResultInfo putAnchorsItem(String key, String anchorsItem) {
    if (this.anchors == null) {
      this.anchors = new HashMap<>();
    }
    this.anchors.put(key, anchorsItem);
    return this;
  }

   /**
   * Get anchors
   * @return anchors
  **/
  @javax.annotation.Nullable
  public Map<String, String> getAnchors() {
    return anchors;
  }

  public void setAnchors(Map<String, String> anchors) {
    this.anchors = anchors;
  }


  public BacklinksAvailableFiltersResultInfo referringDomains(Map<String, String> referringDomains) {
    this.referringDomains = referringDomains;
    return this;
  }

  public BacklinksAvailableFiltersResultInfo putReferringDomainsItem(String key, String referringDomainsItem) {
    if (this.referringDomains == null) {
      this.referringDomains = new HashMap<>();
    }
    this.referringDomains.put(key, referringDomainsItem);
    return this;
  }

   /**
   * Get referringDomains
   * @return referringDomains
  **/
  @javax.annotation.Nullable
  public Map<String, String> getReferringDomains() {
    return referringDomains;
  }

  public void setReferringDomains(Map<String, String> referringDomains) {
    this.referringDomains = referringDomains;
  }


  public BacklinksAvailableFiltersResultInfo domainIntersection(Map<String, String> domainIntersection) {
    this.domainIntersection = domainIntersection;
    return this;
  }

  public BacklinksAvailableFiltersResultInfo putDomainIntersectionItem(String key, String domainIntersectionItem) {
    if (this.domainIntersection == null) {
      this.domainIntersection = new HashMap<>();
    }
    this.domainIntersection.put(key, domainIntersectionItem);
    return this;
  }

   /**
   * Get domainIntersection
   * @return domainIntersection
  **/
  @javax.annotation.Nullable
  public Map<String, String> getDomainIntersection() {
    return domainIntersection;
  }

  public void setDomainIntersection(Map<String, String> domainIntersection) {
    this.domainIntersection = domainIntersection;
  }


  public BacklinksAvailableFiltersResultInfo pageIntersection(Map<String, String> pageIntersection) {
    this.pageIntersection = pageIntersection;
    return this;
  }

  public BacklinksAvailableFiltersResultInfo putPageIntersectionItem(String key, String pageIntersectionItem) {
    if (this.pageIntersection == null) {
      this.pageIntersection = new HashMap<>();
    }
    this.pageIntersection.put(key, pageIntersectionItem);
    return this;
  }

   /**
   * Get pageIntersection
   * @return pageIntersection
  **/
  @javax.annotation.Nullable
  public Map<String, String> getPageIntersection() {
    return pageIntersection;
  }

  public void setPageIntersection(Map<String, String> pageIntersection) {
    this.pageIntersection = pageIntersection;
  }


  public BacklinksAvailableFiltersResultInfo referringNetworks(Map<String, String> referringNetworks) {
    this.referringNetworks = referringNetworks;
    return this;
  }

  public BacklinksAvailableFiltersResultInfo putReferringNetworksItem(String key, String referringNetworksItem) {
    if (this.referringNetworks == null) {
      this.referringNetworks = new HashMap<>();
    }
    this.referringNetworks.put(key, referringNetworksItem);
    return this;
  }

   /**
   * Get referringNetworks
   * @return referringNetworks
  **/
  @javax.annotation.Nullable
  public Map<String, String> getReferringNetworks() {
    return referringNetworks;
  }

  public void setReferringNetworks(Map<String, String> referringNetworks) {
    this.referringNetworks = referringNetworks;
  }


  public BacklinksAvailableFiltersResultInfo domainPagesSummary(Map<String, String> domainPagesSummary) {
    this.domainPagesSummary = domainPagesSummary;
    return this;
  }

  public BacklinksAvailableFiltersResultInfo putDomainPagesSummaryItem(String key, String domainPagesSummaryItem) {
    if (this.domainPagesSummary == null) {
      this.domainPagesSummary = new HashMap<>();
    }
    this.domainPagesSummary.put(key, domainPagesSummaryItem);
    return this;
  }

   /**
   * Get domainPagesSummary
   * @return domainPagesSummary
  **/
  @javax.annotation.Nullable
  public Map<String, String> getDomainPagesSummary() {
    return domainPagesSummary;
  }

  public void setDomainPagesSummary(Map<String, String> domainPagesSummary) {
    this.domainPagesSummary = domainPagesSummary;
  }


  public BacklinksAvailableFiltersResultInfo competitors(Map<String, String> competitors) {
    this.competitors = competitors;
    return this;
  }

  public BacklinksAvailableFiltersResultInfo putCompetitorsItem(String key, String competitorsItem) {
    if (this.competitors == null) {
      this.competitors = new HashMap<>();
    }
    this.competitors.put(key, competitorsItem);
    return this;
  }

   /**
   * Get competitors
   * @return competitors
  **/
  @javax.annotation.Nullable
  public Map<String, String> getCompetitors() {
    return competitors;
  }

  public void setCompetitors(Map<String, String> competitors) {
    this.competitors = competitors;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BacklinksAvailableFiltersResultInfo backlinksAvailableFiltersResultInfo = (BacklinksAvailableFiltersResultInfo) o;
    return Objects.equals(this.contentDuplicates, backlinksAvailableFiltersResultInfo.contentDuplicates) &&
        Objects.equals(this.backlinks, backlinksAvailableFiltersResultInfo.backlinks) &&
        Objects.equals(this.domainPages, backlinksAvailableFiltersResultInfo.domainPages) &&
        Objects.equals(this.anchors, backlinksAvailableFiltersResultInfo.anchors) &&
        Objects.equals(this.referringDomains, backlinksAvailableFiltersResultInfo.referringDomains) &&
        Objects.equals(this.domainIntersection, backlinksAvailableFiltersResultInfo.domainIntersection) &&
        Objects.equals(this.pageIntersection, backlinksAvailableFiltersResultInfo.pageIntersection) &&
        Objects.equals(this.referringNetworks, backlinksAvailableFiltersResultInfo.referringNetworks) &&
        Objects.equals(this.domainPagesSummary, backlinksAvailableFiltersResultInfo.domainPagesSummary) &&
        Objects.equals(this.competitors, backlinksAvailableFiltersResultInfo.competitors);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(contentDuplicates, backlinks, domainPages, anchors, referringDomains, domainIntersection, pageIntersection, referringNetworks, domainPagesSummary, competitors);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BacklinksAvailableFiltersResultInfo {\n");
    sb.append("    contentDuplicates: ").append(toIndentedString(contentDuplicates)).append("\n");
    sb.append("    backlinks: ").append(toIndentedString(backlinks)).append("\n");
    sb.append("    domainPages: ").append(toIndentedString(domainPages)).append("\n");
    sb.append("    anchors: ").append(toIndentedString(anchors)).append("\n");
    sb.append("    referringDomains: ").append(toIndentedString(referringDomains)).append("\n");
    sb.append("    domainIntersection: ").append(toIndentedString(domainIntersection)).append("\n");
    sb.append("    pageIntersection: ").append(toIndentedString(pageIntersection)).append("\n");
    sb.append("    referringNetworks: ").append(toIndentedString(referringNetworks)).append("\n");
    sb.append("    domainPagesSummary: ").append(toIndentedString(domainPagesSummary)).append("\n");
    sb.append("    competitors: ").append(toIndentedString(competitors)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("content_duplicates");
    openapiFields.add("backlinks");
    openapiFields.add("domain_pages");
    openapiFields.add("anchors");
    openapiFields.add("referring_domains");
    openapiFields.add("domain_intersection");
    openapiFields.add("page_intersection");
    openapiFields.add("referring_networks");
    openapiFields.add("domain_pages_summary");
    openapiFields.add("competitors");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to BacklinksAvailableFiltersResultInfo
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!BacklinksAvailableFiltersResultInfo.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in BacklinksAvailableFiltersResultInfo is not found in the empty JSON string", BacklinksAvailableFiltersResultInfo.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!BacklinksAvailableFiltersResultInfo.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `BacklinksAvailableFiltersResultInfo` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!BacklinksAvailableFiltersResultInfo.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'BacklinksAvailableFiltersResultInfo' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<BacklinksAvailableFiltersResultInfo> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(BacklinksAvailableFiltersResultInfo.class));

       return (TypeAdapter<T>) new TypeAdapter<BacklinksAvailableFiltersResultInfo>() {
           @Override
           public void write(JsonWriter out, BacklinksAvailableFiltersResultInfo value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public BacklinksAvailableFiltersResultInfo read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of BacklinksAvailableFiltersResultInfo given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of BacklinksAvailableFiltersResultInfo
  * @throws IOException if the JSON string is invalid with respect to BacklinksAvailableFiltersResultInfo
  */
  public static BacklinksAvailableFiltersResultInfo fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, BacklinksAvailableFiltersResultInfo.class);
  }

 /**
  * Convert an instance of BacklinksAvailableFiltersResultInfo to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

